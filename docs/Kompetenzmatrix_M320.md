# Modul 320 - Objektorientiert Programmieren - Kompetenzmatrix

| **Kompetenz** | **HZ** | **Grundlagen** | **Fortgeschritten** | **Erweitert** |
|---------------|---------------|----------------|--------------------|----------------|
| A - Objektorientiertes Design erstellen | 1 | A1G: Ich kann aus einer einfachen Situationsbeschreibung auf mögliche Klassenkandidaten, Attribute und Methoden schliessen. | A1F: Ich kann unter Berücksichtigung von Delegation mögliche Klassenkandidaten, Attribute und Methoden aus einer einfachen Situationsbeschreibung eruieren und diese abbilden. | A1E: Ich kann komplexere Situationsbeschreibungen analysieren und Klassenkandidaten, Attribute und Methoden definieren und diese in einer Vererbungshierarchie abbilden. |
| B - Objektorientiert modellieren | 2 | B1G: Ich kann den Aufbau einer Applikation auf Grund vorhandener Unterlagen interpretieren und erklären (z.B. anhand von UML Diagrammen). | B1F: Ich kann den Aufbau einer Software modellieren (z.B. Klassen-, Aktivitäten- und Sequenzdiagramm). | B1E: Ich kann das Modell einer Software analysieren, kritische Punkte erkennen und Korrekturen vorschlagen (z.B. statische und dynamische Aspekte, Vererbung, Assoziationen). |
| C - Objektorientiert implementieren | 1, 2, 3 | C1G: Ich kann Klassen unter der Verwendung von Konstruktoren und Methoden definieren und Objekte instanziieren. | C1F: Ich kann ein- und zweiseitige Beziehungen gemäss dem statischen Entwurf implementieren. | C1E: Ich kann Interaktion zwischen den Objekten unter Berücksichtigung des dynamischen Entwurfs umsetzen (Delegation). |
| D - Objektorientiert mit Vererbung implementieren | 1, 2, 3 | D1G: Ich kann Klassen und deren Super-Klassen implementieren und deren Objekte instanziieren. | D1F: Ich kann Methoden in den Sub-Klassen ergänzen oder überschreiben, um so die Fähigkeiten der Klasse zu erweitern oder anzupassen. | - |
|| 1, 2, 3 | D2G: Ich kann eigene Klassen unter Nutzung von Interfaces und abstrakten Klassen aus Bibliotheken implementieren (z.B. AbstractList, Comparator, Comparable). | D2F: Ich kann eigene abstrakte Klassen oder Interfaces gemäss Entwurf implementieren. | D2E: Ich kann Lösungsansätze für komplexe Problemstellungen durch Anwendung der Polymorphie effizient umsetzen. |
| E - Qualitätssicherung | 4 | E1G: Ich kenne Code-Konventionen und kann den Quellcode dementsprechend implementieren. | E1F: Ich kann Code in einer Codereviewsitzung auf dessen Qualität überprüfen. | E1E: Ich kann Code mit vorgegebenen, automatisierten Tests (JUnit) überprüfen. |
|| 2 | E2G: Ich kann erklären, wozu ein Softwaredokumentationswerkzeug (z.B. JavaDoc) dient und wie man es einsetzt (Anwenden von Tags, Generieren der Dokumentation). | E2F: Ich kann Software mit Hilfe von einem Softwaredokumentationswerkzeug dokumentieren (z.B. JavaDoc, Anwenden von Tags, Generieren der Dokumentation). | E2E: Ich kann die Kommentare in einer Software hinterfragen und Vorschläge zur Verbesserung machen (z.B. Vermeiden von Kommentaren durch bessere Struktur, Anwenden von Clean-Code-Regeln). |

## Handlungsziele
1. Analysiert Anwendungsprobleme zur Erstellung von objektorientierten Programmen.
2. Modelliert und dokumentiert objektorientierte Programme.
3. Implementiert objektorientiertes Design.
4. Überprüft die Implementierung auf Korrektheit und Qualität.
